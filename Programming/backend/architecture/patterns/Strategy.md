#pattern #snippet #architecture #php
**Strategy** — это поведенческий шаблон проектирования, который используется для определения семейства взаимозаменяемых алгоритмов. Он позволяет их выбирать в зависимости от ситуации, изменять во время выполнения программы, а также минимизировать использование громоздких условных операторов (`if-else` или `switch`).

---
#### Зачем нужен паттерн Strategy?

1. **Упростить код**:
   - Позволяет заменить длинные условные конструкции, которые выбирают алгоритм выполнения действия, на структуры с четким объектно-ориентированным подходом.
   
2. **Динамически управлять поведением**:
   - Код легко адаптировать к разным ситуациям, изменяя поведение объектов во время выполнения программы.

3. **Обеспечить расширяемость**:
   - Добавление новых алгоритмов (стратегий) не повлияет на основной код, соблюдая *принцип открытости/закрытости (OCP)*.

4. **Инкапсулировать поведение**:
   - Логика каждого из алгоритмов находится в отдельном классе, что способствует повторному использованию кода и облегчает тестирование.

#### Как работает паттерн Strategy?

В паттерне Strategy участвуют три основные сущности:

1. **Контекст** (Context):
   - Класс, который использует одну из реализованных стратегий. Контекст делегирует операцию текущей стратегии.

2. **Интерфейс стратегии** (Strategy):
   - Определяет общий интерфейс для всех стратегий (действий, алгоритмов).

3. **Конкретные стратегии** (ConcreteStrategies):
   - Разные реализации алгоритмов, которые соответствуют интерфейсу стратегии.

#### Когда применять паттерн Strategy?

1. **Несколько вариантов поведения**:
   - Когда необходимо иметь разные реализации логики на основе входных данных или других условий.

2. **Избавление от громоздких условных конструкций**:
   - Когда вы используете большое количество `if-else` или `switch-case`, подход Strategy помогает организовать код более чисто и структурированно.

3. **Новые алгоритмы и расширяемость**:
   - Когда нужно добавить новый алгоритм без изменения уже существующего функционала.

4. **Изменение поведения объектов на лету**:
   - Когда алгоритм, используемый объектом, должен задаваться или изменяться динамически.

#### Пример использования паттерна Strategy (на PHP)

Давайте рассмотрим пример, где мы реализуем систему расчета стоимости оплаты в зависимости от разных способов оплаты: "Картой", "PayPal", "Криптовалютой". Здесь паттерн Strategy помогает удобно управлять этими способами:

**1. Определяем интерфейс стратегии:**

```php
interface PaymentStrategy
{
    public function pay(float $amount): string;
}
```

Каждая стратегия должна реализовать этот интерфейс и определить метод `pay`, который принимает сумму.

**2. Реализуем конкретные стратегии:**

```php
class CreditCardPayment implements PaymentStrategy
{
    public function pay(float $amount): string
    {
        return "Оплачено {$amount} картой";
    }
}

class PayPalPayment implements PaymentStrategy
{
    public function pay(float $amount): string
    {
        return "Оплачено {$amount} через PayPal";
    }
}

class CryptoPayment implements PaymentStrategy
{
    public function pay(float $amount): string
    {
        return "Оплачено {$amount}₽ криптовалютой";
    }
}
```

Каждая стратегия реализует свою уникальную логику обработки оплаты.

**3. Создаем контекст:**

```php
class PaymentProcessor
{
    private PaymentStrategy $paymentStrategy;

    // Устанавливаем стратегию оплаты
    public function setPaymentStrategy(PaymentStrategy $strategy): void
    {
        $this->paymentStrategy = $strategy;
    }

    // Выполняем оплату
    public function processPayment(float $amount): string
    {
        return $this->paymentStrategy->pay($amount);
    }
}
```

Контекст `PaymentProcessor` принимает стратегию и использует её для выполнения соответствующей операции.

**4. Используем паттерн в клиентском коде:**

```php
// Создаём процессор для оплаты
$paymentProcessor = new PaymentProcessor();

// Оплата картой
$paymentProcessor->setPaymentStrategy(new CreditCardPayment());
echo $paymentProcessor->processPayment(1000); // "Оплачено 1000 картой"

// Оплата через PayPal
$paymentProcessor->setPaymentStrategy(new PayPalPayment());
echo $paymentProcessor->processPayment(1500); // "Оплачено 1500 через PayPal"

// Оплата криптовалютой
$paymentProcessor->setPaymentStrategy(new CryptoPayment());
echo $paymentProcessor->processPayment(2000); // "Оплачено 2000 криптовалютой"
```

#### Преимущества паттерна Strategy:

1. **Инкапсуляция и чистота кода**:
   - Логика алгоритма изолирована в отдельных классах, что облегчает чтение и поддержку.

2. **Принцип открытости/закрытости (OCP)**:
   - Добавление новой стратегии не требует изменения существующего кода; требуется только создать новую реализацию интерфейса.

3. **Избегание дублирования**:
   - Общие компоненты кода располагаются в контексте, а уникальная логика в отдельных стратегиях.

4. **Изменение поведения на лету**:
   - Можно динамически переключать поведение объекта, подставляя разные стратегии.

#### Недостатки паттерна Strategy:

1. **Увеличение количества классов**:
   - Для каждой стратегии требуется отдельный класс, что может привести к усложнению проекта (особенно при большом количестве алгоритмов).

2. **Иногда кажется переусложнением**:
   - В простых случаях может показаться излишним, если алгоритмов мало и они редко изменяются.

#### Примеры использования в реальной жизни:

1. **Логистика**:
   - Расчет стоимости доставки (например, наземным транспортом, воздушным, морским).

2. **Авторизация и аутентификация**:
   - Разные методы входа в систему (через email, соцсети, одноразовые пароли и т.д.).

3. **Форматирование данных**:
   - Упаковка данных в различные форматы (JSON, XML, CSV и прочие).

4. **Выбор платежных систем**:
   - Разные способы оплаты (банковская карта, PayPal, криптовалюта).

5. **Рендеринг графики**:
   - Различные алгоритмы рендеринга изображений или анимации (в играх, 2D/3D приложениях).

---
### Краткое заключение

Паттерн **Strategy** удобен там, где требуется выбирать между несколькими алгоритмами или обработчиками, не усложняя основной код и не создавая бесконечных ветвлений с `if-else`. Он способствует написанию кода, который легко расширяется и поддерживается. Если вы сталкиваетесь с задачей, требующей выбора алгоритма или поведения, **Strategy** — это отличное решение.