#pattern #architecture #php 
**Composite** (Компоновщик) — это структурный паттерн проектирования, который позволяет клиентам работать с отдельными объектами и группами объектов одинаково, как с единым целым. Он объединяет объекты в древовидную структуру для представления иерархий **«часть-целое»**.
Идея заключается в том, чтобы организовать объекты в деревья, а все операции, применимые к ветвям дерева, также можно было бы применять и к их узлам (листьям). Это позволяет обрабатывать сложные структуры единообразно.

---

#### Пример реальной жизни
Дерево каталогов и файлов в операционной системе:
- Есть папки (группы объектов), которые содержат файлы или другие папки.
- Но для пользователя файл и папка предоставляют одинаковый интерфейс — например, команду **«удалить»** можно вызвать как для файла, так и для папки. В случае с папкой эта команда удаляет содержимое папки рекурсивно.

#### Структура паттерна **Composite**
У паттерна Composite есть 3 ключевых компонента:
1. **Component** (Компонент) - общий интерфейс для всех объектов в дереве.
    - Определяет операции, которые могут быть выполнены как для отдельных объектов, так и для их групп.

2. **Leaf (Лист)** - конкретный класс, который не имеет потомков (конечный объект, например, "файл").
    - Реализует интерфейс компонента.

3. **Composite (Контейнер)** - узел дерева, который может содержать другие компоненты (как листья, так и другие контейнеры).
    - Хранит и управляет вложенными объектами.
    - Реализует интерфейс компонента и умеет выполнять операции с вложенными элементами.

#### Пример на PHP
Давайте смоделируем файловую систему:

``` php
// Общий интерфейс для файла и папки

interface FileSystemItem
{
    public function getName(): string;
    public function getSize(): int;
}

// Класс для "листа" - файла
class File implements FileSystemItem
{
    private string $name;
    private int $size;

    public function __construct(string $name, int $size)
    {
        $this->name = $name;
        $this->size = $size;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function getSize(): int
    {
        return $this->size;
    }
}

// Класс для "компоновщика" - папки
class Folder implements FileSystemItem
{
    private string $name;
    private array $items = []; // Список файлов и подпапок

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function addItem(FileSystemItem $item): void
    {
        $this->items[] = $item;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function getSize(): int
    {
        $totalSize = 0;
        foreach ($this->items as $item) {
            $totalSize += $item->getSize();
        }
        return $totalSize;
    }

    public function getItems(): array
    {
        return $this->items;
    }
}

// Пример использования
$file1 = new File("file1.txt", 500);
$file2 = new File("file2.jpg", 1500);

$folder = new Folder("MyFolder");
$folder->addItem($file1);
$folder->addItem($file2);

$subFolder = new Folder("SubFolder");
$subFolder->addItem(new File("subfile1.doc", 700));
$folder->addItem($subFolder);

echo $folder->getName() . " size: " . $folder->getSize() . " bytes\n";
 
// Вывод
MyFolder size: 2700 bytes
```

#### Как это работает?
1. **Лист (File)** — это конечные объекты, которые не содержат в себе других объектов и реализуют общий интерфейс `FileSystemItem`.
2. **Компоновщик (Folder)** — это контейнер, который может содержать другие компоненты, включая листья и подкомпоновщики.
3. Когда вы вызываете метод `getSize()` для папки, он рекурсивно вызывает `getSize()` для всех вложенных объектов.

#### Плюсы паттерна Composite
1. **Единый интерфейс для работы с деревом**:
    - Клиенту не нужно знать, работает он с отдельным объектом (листом) или с их группой (контейнером). Оно всё обрабатывается одинаково (полиморфизм).
2. **Проще добавлять новые элементы структуры**:
    - Вы легко можете добавить новый тип компонента, который реализует основной интерфейс.
3. **Гибкость структуры**:
    - Вы можете создавать сложные древовидные системы из объектов, сгруппировывая их так, как нужно. Узлы и листья можно комбинировать произвольно.
4. **Рекурсивная обработка**:
    - Структура дерева позволяет легко написать рекурсивные алгоритмы (например, подсчёт общего размера, удаление ветвей).

### Минусы паттерна Composite
1. **Сложность кода**:
    - Становится сложнее понять и поддерживать, особенно если дерево имеет многоуровневую вложенность.
2. **Может быть избыточным**:
    - Если у вас нет чёткой необходимости в обработке иерархических структур, паттерн может усложнить проект.
3. **Трудные ограничения**:
    - В обобщённой структуре (где узлы и листья равноправны) сложно накладывать ограничения (например, что у узла могут быть только листья определённого типа).

#### Когда использовать **Composite**
1. **Если у вас есть древовидная структура объектов.**
    - Например, файловая система, меню на сайте (с вложенными пунктами), организация сотрудников в компании (иерархия подчинения), графические элементы (панели и кнопки).
2. **Если вы хотите работать с отдельными объектами и их группами одинаково.**
    - Например, обработка JSON или XML-документов, где могут быть вложенные объекты.
3. **Если требуется объединить множество объектов в общую структуру.**
    - Например, вы строите графический редактор, в котором отдельные фигуры (линии, прямоугольники и т.д.) можно сгруппировать.

### Реальные примеры использования

#### 1. **Графическая система**
- Рисунок состоит из элементов: линии, прямоугольники, круги, которые группируются в более крупные элементы (например, фигура состоит из нескольких линий).

``` php
interface Graphic {
    public function render();
}

class Circle implements Graphic {
    public function render() {
        echo "Rendering Circle.\n";
    }
}

class Group implements Graphic {
    private $graphics = [];

    public function addGraphic(Graphic $graphic) {
        $this->graphics[] = $graphic;
    }

    public function render() {
        foreach ($this->graphics as $graphic) {
            $graphic->render();
        }
    }
}
```

#### Отличие от других паттернов
1. **Composite vs Decorator**
    - Composite объединяет объекты в древовидные структуры, в то время как Decorator добавляет дополнительное поведение объёмно и каскадно.
2. **Composite vs Facade**
    - Facade предоставляет простой интерфейс к подсистеме, скрывая её внутренности. Composite организует объекты и позволяет взаимодействовать с деревом узлов/листьев как с единым целым.

#### Заключение
**Composite** — это мощный паттерн для работы с иерархиями «часть-целое», который упрощает управление сложными деревовидными структурами. Его основное преимущество — возможность работы с отдельными объектами и их группами через единый интерфейс.