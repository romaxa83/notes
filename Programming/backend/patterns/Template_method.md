#pattern #architecture #php
**Шаблонный метод (Template Method Pattern)** — поведенческий паттерн проектирования, который определяет основы алгоритма в базовом классе, предоставляя возможность потомкам переопределять или дополнять часть поведения, не изменяя структуры алгоритма.

---

Идея шаблона заключается в следующем:
1. Базовый класс **задает общий порядок выполнения методов/алгоритма**.
2. Конкретные шаги алгоритма делегируются методам, которые могут быть **переопределены** в подклассах для выполнения специфической логики.

Это достигается с помощью:
- Абстрактных методов, которые обязаны реализовать потомки.
- Обычных методов, которые уже определены в базовом классе, но могут обращаться к переопределенным методам в потомках.

Использование позднего статического связывания (`static`) особенно полезно, если какие-либо методы являются **статическими**.
### Архитектура шаблонного метода
1. **Базовый класс**: определяет шаблонный метод, который описывает общий алгоритм.
2. **Дочерние классы**: переопределяют абстрактные или специфические шаги алгоритма, чтобы реализовать собственную функциональность.

### Пример: Генерация отчета с использованием шаблонного метода
Представим, что у нас есть базовый класс `Report`, который задает общий интерфейс для генерации отчетов. Разные отчеты (`SalesReport`, `InventoryReport`) имеют различное содержимое, но общий процесс формирования:
- Шаблон:
    1. Установить заголовок.
    2. Добавить таблицу.
    3. Завершить отчет.

``` php
abstract class Report
{
    // Шаблонный метод, описывающий общий алгоритм
    public static function generate()
    {
        static::setHeader(); // Установка заголовка
        static::addContent(); // Добавление содержимого (таблиц, данных)
        static::finishReport(); // Финализация отчета
    }

    // Шаг 1: Установка заголовка (каждый отчет имеет свой заголовок)
    protected static function setHeader()
    {
        echo "Заголовок: " . static::getTitle() . PHP_EOL;
    }

    // Шаг 2: Добавление содержимого
    protected static function addContent()
    {
        echo "Содержимое: " . static::getContent() . PHP_EOL;
    }

    // Шаг 3: Финализация (может быть общая для всех отчетов)
    protected static function finishReport()
    {
        echo "Отчет полностью сформирован." . PHP_EOL;
    }

    // Абстрактный метод для заголовка (обязателен к реализации)
    abstract protected static function getTitle(): string;

    // Абстрактный метод для содержимого (обязателен к реализации)
    abstract protected static function getContent(): string;
}
```

*отчет о продажах*
``` php
class SalesReport extends Report
{
    protected static function getTitle(): string
    {
        return "Отчет о продажах";
    }

    protected static function getContent(): string
    {
        return "Данные о продажах за месяц.";
    }
}
```

*отчет о запасах*
``` php
class InventoryReport extends Report
{
    protected static function getTitle(): string
    {
        return "Отчет о запасах";
    }

    protected static function getContent(): string
    {
        return "Информация о текущих запасах.";
    }
}
```

*Вызов шаблонного метода*
``` php
// Генерация отчета о продажах
SalesReport::generate();
// Вывод:
// Заголовок: Отчет о продажах
// Содержимое: Данные о продажах за месяц.
// Отчет полностью сформирован.

// Генерация отчета о запасах
InventoryReport::generate();
// Вывод:
// Заголовок: Отчет о запасах
// Содержимое: Информация о текущих запасах.
// Отчет полностью сформирован.
```

**Разбор кода**
1. **Абстрактный класс `Report`**:
    - Определяет общий алгоритм в методе `generate()`.
    - Определяет шаги, выполняемые в рамках алгоритма, но сам не знает, как именно их выполнять.

2. **Методы, которые нужно перегрузить**:
    - Подклассы обязаны реализовать `getTitle()` и `getContent()`, чтобы создать специфическое поведение.

3. **Позднее статическое связывание**:
    - Благодаря `static::methodName()`, вызовы методов `setHeader()`, `addContent()`, `getTitle()` происходят в контексте класса, откуда вызван `generate()`, что позволяет шаблонному методу быть гибким.

4. **Полезность шаблонного метода**:
    - Вы можете добавлять новые типы отчетов (например, `ProfitReport` или `EmployeeReport`), просто создавая новые классы с собственной реализацией специфических шагов, не меняя родительский код.

#### Применимость шаблонного метода
Вы можете использовать этот паттерн, если:
1. **Общий алгоритм повторяется** для разных процессов, но отдельные шаги должны быть реализованы для каждого случая.
2. Вы хотите выделить **стратегию изменения** в один или несколько методов, чтобы сделать их легко расширяемыми в подклассах.
3. **Наследники должны переопределять отдельные шаги**, но не весь алгоритм.

### Другой пример: Обработка файлов
Допустим, у нас есть процесс обработки файлов разных форматов: текстовые файлы, CSV и XML. Общий процесс один:
1. Открыть файл.
2. Прочитать содержимое.
3. Проанализировать данные файла.
4. Закрыть файл.

*Базовый класс*
``` php
abstract class FileProcessor
{
    public function process(string $filePath)
    {
        $this->openFile($filePath);
        $content = $this->readFile();
        $this->analyzeData($content);
        $this->closeFile();
    }

    protected function openFile(string $filePath)
    {
        echo "Открытие файла: $filePath" . PHP_EOL;
    }

    abstract protected function readFile(): string;

    abstract protected function analyzeData(string $content): void;

    protected function closeFile()
    {
        echo "Закрытие файла." . PHP_EOL;
    }
}

```

*Реализация для текстового файла*
``` php
class TextFileProcessor extends FileProcessor
{
    protected function readFile(): string
    {
        return "Содержимое текстового файла";
    }

    protected function analyzeData(string $content): void
    {
        echo "Анализ данных текстового файла: $content" . PHP_EOL;
    }
}
```

*Реализация для XML файла*
``` php
class XmlFileProcessor extends FileProcessor
{
    protected function readFile(): string
    {
        return "<xml>Данные XML файла</xml>";
    }

    protected function analyzeData(string $content): void
    {
        echo "Анализ XML: $content" . PHP_EOL;
    }
}
```

*Вызов*
``` php
// Обработка текстового файла
$textProcessor = new TextFileProcessor();
$textProcessor->process("text.txt");

// Обработка XML файла
$xmlProcessor = new XmlFileProcessor();
$xmlProcessor->process("data.xml");
```

### Заключение
- **Шаблонный метод** позволяет вынести общую часть алгоритма в базовый класс, оставив детали реализации методам-наследникам.
- Это помогает добиться высокой **гибкости, повторного использования и удельного разделения ответственности**.
- Используется везде, где вы можете выделить **общий процесс**, но при этом отдельные шаги зависят от конкретных случаев использования.